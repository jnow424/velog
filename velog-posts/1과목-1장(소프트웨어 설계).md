<p>1.과목 소프트웨어 설계</p>
<p>1장 요구사항 확인</p>
<hr />
<p>1-1. 소프트웨어 생명 주기
개발 방법론의 바탕이 되는것
개발, 운용, 유지보수 </p>
<p>모형: </p>
<ul>
<li><p>폭포수</p>
<ul>
<li>가장 오래됨</li>
<li>폭넓게 사용된 전통적인</li>
<li>고전적 생명 주기 모형</li>
<li>사용량이 많음</li>
<li>모형을 적용한 경험괴 성공 사례가 많음 (오래됬으니 당연한)</li>
<li>두 개 이상의 과정이 병행하여 수행되지 않음</li>
<li>타당성 검토(할까? 말까?/고민) &gt; 계획(비용,조직도) &gt; 요구분석(고객요구사항 100%) &gt; 설계 구현(코딩) &gt; 시험(검사) &gt; 유지보수</li>
</ul>
</li>
<li><p>프로토타입</p>
<ul>
<li>견본, 시제품, 샘플</li>
<li>사용자의 요구사항을 정확히 파악하기 위해</li>
<li>최종 결과물을 예측</li>
<li>의뢰자, 개발자 공동의 참조</li>
<li>단기간 제작을 목적(개발시간이 짧음)</li>
<li>비효율적인 언어나 알고리즘이 사용될 수 있음</li>
</ul>
</li>
<li><p>나선형(Spiral, 점진적)</p>
<ul>
<li>보헴</li>
<li>폭포수 + 프로토타입 =&gt; 장점에 '위험분석' 기능 추가</li>
<li>계획수립 &gt; 위험분석 &gt; 개발 및 검증 &gt; 고객 평가</li>
<li>대규모 프로젝트에 많이 사용</li>
</ul>
</li>
<li><p>애자일</p>
<ul>
<li>일정한 주기를 반복하면서 개발과정을 진행</li>
<li>어느 특정 개발 방법론 X</li>
<li>고객과 '소통'에 초점을 맞춘 방법론을 통칭</li>
<li>스프린트(Sprint) or 이터레이션(Iteration)</li>
<li>애자일 개발 4가지 핵심 가치 <ul>
<li>개인과 상호작용</li>
<li>실행되는 SW</li>
<li>고객과 협업</li>
<li>변화에 반응하는 것(고객의 반응에 호응)</li>
</ul>
</li>
<li>애자일 개발 12가지 실행 지침<ul>
<li>고객을 만족</li>
<li>요구사항 변경을 적극 수용</li>
<li>얼굴을 맞대고 의견을 나눔</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>폭포수 모형과 애자일의 비교</p>
<ul>
<li>새로운 요구사항 반영:   애자일 &gt; 지속적으로 반영</li>
<li>고객과 의사소통:           애자일 &gt; 지속적임</li>
<li>테스트 :                        애자일 &gt; 반복되는 일정 주기가 끝날 때마다 테스트</li>
<li>개발 중심:                     애자일 &gt;고객</li>
</ul>
<p>*
1-2. 스크럼 기법
팀이 중심, 스스로 해결</p>
<p>제품 책임자(PO; product Owner)</p>
<ul>
<li>개발될 제품에 대한 이해도가 높다 &gt; 요청한 사람, 사용자,의뢰자</li>
<li>의견 종합 &quot;요구사항&quot;을 작성하는 주체</li>
<li>요구사항이 담긴 &quot;백로그(요구사항을 정리한 목록)&quot; 작성</li>
<li>&quot;우선순위&quot; </li>
</ul>
<p>스크럼 마스터(SM) / 조정자</p>
<ul>
<li>&quot;조언&quot;</li>
<li>팀원들을 통제하는 것이 목표 &quot;X&quot;</li>
</ul>
<p>개발팀(DT; Development Team)</p>
<ul>
<li>제품 책임자, 스크럼 마스터 제외한 모두</li>
<li>최대 7~8명 적당</li>
</ul>
<p>스크럼 개발 프로세스</p>
<ul>
<li>스프린트 계획 회의 (단기간)
스프린트</li>
<li>&quot;2~4주&quot;
일일 스크럼 회의</li>
<li>소멸 차트(B_D C)<ul>
<li>시간의 경과에 따라 남은 작업 시간</li>
<li>작업이 진행될수록 점점 줄어드는게 정상</li>
<li>스크럼 마스터는 발견된 장애 요소를 해결할 수 있도록 도와줌</li>
</ul>
</li>
<li>스프린트 검토 회의<ul>
<li>요구사항에 잘 부합되는지 사용자가 포함된 참석자 앞에서 테스팅을 수행</li>
<li>한 주당 한 시간</li>
<li>&quot;제품 책임자 &gt; 백로그&quot;</li>
</ul>
</li>
</ul>
<p>**
1-3. XP 기법</p>
<ul>
<li>&quot;고객&quot;의 요구사항에 유연하게 대응하기 위한 방법</li>
<li>&quot;짧고 반복&quot;적인 개발주기</li>
<li>&quot;단순&quot;한 설게</li>
<li>&quot;고객&quot;의 적극적인 &quot;참여&quot;</li>
<li>릴리즈(버전의 하위 단계)의 기간<ul>
<li>짧게 반복,  요구사항 가시성</li>
<li>&quot;테스트&quot;마다 &quot;고객&quot;을 직접 참여시킴</li>
<li>소규모 인원</li>
<li>애자일(고객, 소통)</li>
</ul>
</li>
<li>XP의 5가지 핵심 가치: 의사소통, 단순성, 용기, 존중, 피드백</li>
</ul>
<p>이터레이션</p>
<ul>
<li>릴리즈를 더 세분화 &gt; 짧은 주기</li>
<li>1~3주
승인검사(인수테스트) / 사용자</li>
<li>고객이 직접 수행
XP의 주요 실천 방법</li>
<li>Pair Programming(짝): &quot;책임&quot;을 공동으로 나눠 갖는 환경</li>
<li>Collective Ownership(공동 코드 소유): 개발코드-권한, 책임 공동 소유</li>
<li>Test-Driven Development(테스트 주도 개발): 테스트 먼저</li>
<li>Whole Team(전체 팀): 각자 자신의 역할이 있고 책임을 다해야함</li>
<li>Continuous Integration(계속적인 통합): 모듈 단위로 나눠 마무리 될때 마다 통합</li>
<li>Disign Improvement(디자인 개선) 또는 Refactoring(리팩토링): 변경없이 단순화, 유언성 강화/시스템 재구성</li>
<li>Small Rleases(소규모 릴리즈): 릴리즈 기간을 짧게 반복 &gt; 고객 요규 변화 신속히 대응</li>
</ul>
<p>*
1-4.현행 시스템 파악</p>
<ul>
<li>1단계<ul>
<li>시스템 &quot;구성, 기능, 인터페이스&quot; 파악</li>
</ul>
</li>
<li>2단계<ul>
<li>&quot;아키텍처, 소프트웨어&quot; 구성 파악</li>
</ul>
</li>
<li>3단계<ul>
<li>&quot;하드웨어, 네트워크&quot; 구성 파악</li>
</ul>
</li>
</ul>
<p>*
1-5. 개발 기술 환경의 정의</p>
<ul>
<li>&quot;운영체제, 데이터베이스(DBMS), 미들웨어&quot; 사용 시 고려사항 오픈 소스 사용 시 주의 사항 제시</li>
<li>운영체제 관련 요구사항 식별 시 고려사항<ul>
<li>가용성(신뢰성): 재가동</li>
<li>주변기기(상호 호완성)</li>
</ul>
</li>
<li>데이터베이스 관리 시스템(DBMS)<ul>
<li>데이터베이스를 관리해 주는소프트웨어</li>
</ul>
</li>
</ul>
<p>**
1-6. 요구사항 정의</p>
<ul>
<li>요구사항의 개념 및 특징<ul>
<li>제약조건</li>
<li>유지 보수 과정, 기준과 근거</li>
</ul>
</li>
</ul>
<p>-요구사항의 유형
    - 기능 요구사항
        - 시스템이 무엇을 하는지
        - 시스템의 입,출력
        - 저장, 연산
        - 시스템이 반드시 수행해야 하는 기능</p>
<ul>
<li><p>비기능 요구사항</p>
<ul>
<li>보안(무결성)
   -인증: 기밀성(아무나 수정x), 무결성(정확), 가용성(언제나)</li>
<li>제약사항(제약조건)</li>
</ul>
</li>
<li><p>요구사항 개발 프로세스</p>
<ul>
<li>도출(모집) &gt; 분석 &gt; 명세(우선순위 리스트) &gt; 확인(검증)</li>
</ul>
</li>
<li><p>요구공학
  -요구사항을 연구하는 학문</p>
</li>
<li><p>요구사항 도출</p>
<ul>
<li>시스템,사용자 ~ 요구사항이 어디에 있는지, 어떻게 수집할 것인지 식별</li>
<li>소프트웨어가 해결해야 할 문제를 이해하는 첫 번째 단계</li>
<li>청취, 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스(명세List/사용자의 요구사항 기능 단위로 표현)</li>
</ul>
</li>
<li><p>요구사항 분석</p>
<ul>
<li>명확하지 않거나 모호 ~ 걸러내기 위한 과정</li>
<li>비용과 일정에 대한 제약을 설정한다.</li>
<li>중복 or 통합 중재 과정</li>
<li>범위를 파악</li>
</ul>
</li>
<li><p>요구사항 명세</p>
<ul>
<li>문서화하는 것 </li>
<li>기능 요구사항 ~ 완전하고 명확하게 ~ 비기능 요구사항 ~ 필요한 것만 명확하게</li>
</ul>
</li>
<li><p>요구사항 명세 기법</p>
<ul>
<li>정형: 수학적 기호</li>
<li>비정형: 자연어 기반, 서술 or 다이어그램</li>
</ul>
</li>
<li><p>요구사항 확인</p>
<ul>
<li>Validation(확인)</li>
<li>Verification(검증)</li>
</ul>
</li>
</ul>
<hr />
<p>1-7. 요구사항 분석</p>
<ul>
<li><p>개발의 실제적인 첫 단계</p>
</li>
<li><p>요구사항을 이해 &gt; 문서화(명세화)</p>
</li>
<li><p>애자일 방법(요구사항, 소통)</p>
</li>
<li><p>자료흐름도(DFD)</p>
<ul>
<li><p>자료 흐름 그래프, 버블 차트</p>
</li>
<li><p>프로세스(Process) &gt; 물품확인(원형)</p>
</li>
<li><p>자료흐름(Data Flow) &gt; 물품코드(화살표)</p>
</li>
<li><p>자료 저장소(Data Store) &gt; 물품대장(위아래 직선)</p>
</li>
<li><p>단말(Terminator) &gt; 공장(사각형)</p>
</li>
<li><p>작성 지침</p>
<ul>
<li>새로운 이름</li>
</ul>
</li>
</ul>
</li>
<li><p>자료 사전 (기호로 만들어짐; 정형)</p>
<ul>
<li>DD(Data Dictionary)</li>
<li>기록</li>
<li>데이터를 설명하는 데이터</li>
<li>데이터의 데이터</li>
<li>메타 데이터(Meta Data)</li>
</ul>
</li>
</ul>
<p>**
1-8. 요구사항 분석 CASE 와 HIPO</p>
<ul>
<li><p>요구사항 분석을 위한 CASE(자동화 도구)</p>
<ul>
<li><p>문서화 품질 개선</p>
</li>
<li><p>결함, 생략, 불일치</p>
</li>
<li><p>유지보수 비용의 축소</p>
</li>
<li><p>종류</p>
<ul>
<li>SADT(S~T)<ul>
<li>SoftTech</li>
<li>구조적 분석 및 설계 도구</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HIPO(계층)</p>
<ul>
<li>하향식 소프트웨어 개발(구조적)</li>
<li>기호, 도표 등을 사용하므로 보기 쉽고 이해하기도 쉬움</li>
<li>HIPO Chart의 종류<ul>
<li>가시적 도표(Visual Table of Contents)<ul>
<li>전체적 기능과 흐름을 보여줌, 계층(Tree) 구조도</li>
</ul>
</li>
<li>총체적 도표(Overview Diagram)<ul>
<li>입력, 처리, 출력에 대한 전반적인 정보를 제공</li>
</ul>
</li>
<li>세부적 도표(Detail Diagram)<ul>
<li>기본 요소들을 상세히 기술</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<p>1-9 UML(Unified Modeling Language)</p>
<ul>
<li><p>UML의 개요</p>
<ul>
<li>객체지향 모델링 언어</li>
<li>Rumbaugh(OMT), Booch, Jacobson</li>
<li>객체지향 방법론의 장점을 통합</li>
</ul>
</li>
<li><p>사물(Things)</p>
<ul>
<li>구조, 행동, 그룹, 주해</li>
</ul>
</li>
<li><p>일반화(Generalization)</p>
<ul>
<li>일반적 인지 구체적 인지</li>
<li>일반적인 개념 &gt; 상위(부모), 보다 구체적인 개념 &gt; 하위(자식)    </li>
</ul>
</li>
<li><p>다이어그램(Diagram)</p>
<ul>
<li>정적 모델링 - 구조적 다이어그램<ul>
<li>클래스 다이어그램</li>
<li>객체 다이어그램 / 럼바우, 객체 모델링</li>
<li>컴포넌트 아이어그램</li>
<li>배치 다이어그램</li>
<li>복합체 구조 다이어그램</li>
<li>패키지 다이어그램</li>
</ul>
</li>
<li>동적 모델링 - 행위 다이어그램<ul>
<li>유스케이스 다이어그램</li>
<li>순차 다이어그램</li>
<li>커뮤니케이션 다이어그램</li>
<li>상태 다이어그램</li>
<li>활동 다이어그램</li>
<li>상호작용 개요 다이어그램</li>
<li>타이밍 다이어그램<ul>
<li>스테레오 타입
&lt;&gt; 포함 관계
&lt;&gt; 확장 관계</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<p>  1-10. 주요 UML 다이어그램</p>
<ul>
<li><p>유스케이스(Use Case) 다이어그램</p>
<ul>
<li>사용자의 요구사항을 분석하기 위한 도구</li>
<li>구성요소<ul>
<li>시스템 범위, 액터, 유스케이스(상품조회가능), 관계</li>
</ul>
</li>
</ul>
</li>
<li><p>순차(Sequence) 다이어그램</p>
<ul>
<li>시간의 흐름에 따라 상호 작용하는 과정</li>
</ul>
</li>
</ul>